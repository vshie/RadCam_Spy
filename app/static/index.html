<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RadCam Spy</title>
  <link href="/static/vendor/vuetify.min.css" rel="stylesheet" />
  <link href="/static/vendor/mdi/css/materialdesignicons.min.css" rel="stylesheet" />
  <script src="/static/vendor/vue.global.prod.js"></script>
  <script src="/static/vendor/vuetify.min.js"></script>
  <script src="/static/vendor/chart.umd.min.js"></script>
  <style>
    @font-face { font-family: 'Inter'; font-style: normal; font-weight: 400; font-display: swap; src: url('/static/vendor/fonts/Inter-Regular.woff2') format('woff2'); }
    @font-face { font-family: 'Inter'; font-style: normal; font-weight: 500; font-display: swap; src: url('/static/vendor/fonts/Inter-Medium.woff2') format('woff2'); }
    @font-face { font-family: 'Inter'; font-style: normal; font-weight: 600; font-display: swap; src: url('/static/vendor/fonts/Inter-SemiBold.woff2') format('woff2'); }
    html, body { margin: 0; padding: 0; background: #0f1117; font-family: 'Inter', sans-serif; }
    [v-cloak] { display: none; }
    .v-table td { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>
  <div id="app" v-cloak>
    <v-app theme="dark">
      <v-app-bar density="compact" color="surface">
        <v-app-bar-title>
          <v-icon class="mr-2">mdi-home-search</v-icon>
          RadCam Spy
        </v-app-bar-title>
        <template v-slot:append>
          <v-chip :color="statusColor" variant="flat" size="small" class="mr-2">
            <v-icon start size="x-small">mdi-circle</v-icon>
            {{ statusLabel }}
          </v-chip>
        </template>
      </v-app-bar>

      <v-main>
        <v-container fluid class="pa-4">
          <v-row>
            <!-- Settings Card -->
            <v-col cols="12" md="6">
              <v-card>
                <v-card-title>
                  <v-icon class="mr-2">mdi-cog</v-icon>Settings
                </v-card-title>
                <v-card-text>
                  <v-text-field
                    v-model="settings.camera_ip"
                    label="Camera IP"
                    prepend-inner-icon="mdi-ip-network"
                    variant="outlined"
                    density="compact"
                    class="mb-2"
                    :disabled="status.running"
                  ></v-text-field>
                  <v-text-field
                    v-model="settings.telnet_user"
                    label="Telnet Username"
                    prepend-inner-icon="mdi-account"
                    variant="outlined"
                    density="compact"
                    class="mb-2"
                    :disabled="status.running"
                  ></v-text-field>
                  <v-text-field
                    v-model="settings.telnet_password"
                    label="Telnet Password"
                    prepend-inner-icon="mdi-lock"
                    variant="outlined"
                    density="compact"
                    class="mb-2"
                    :type="showPassword ? 'text' : 'password'"
                    :append-inner-icon="showPassword ? 'mdi-eye-off' : 'mdi-eye'"
                    @click:append-inner="showPassword = !showPassword"
                    :disabled="status.running"
                  ></v-text-field>
                  <v-text-field
                    v-model.number="settings.interval"
                    label="Sampling Interval (seconds)"
                    prepend-inner-icon="mdi-timer-outline"
                    variant="outlined"
                    density="compact"
                    type="number"
                    min="0.5"
                    step="0.5"
                    :disabled="status.running"
                  ></v-text-field>
                </v-card-text>
                <v-card-actions>
                  <v-btn
                    color="primary"
                    variant="flat"
                    :loading="savingSettings"
                    :disabled="status.running"
                    @click="saveSettings"
                  >
                    <v-icon start>mdi-content-save</v-icon>Save
                  </v-btn>
                  <v-spacer></v-spacer>
                  <v-chip v-if="settingsSaved" color="success" size="small" variant="tonal">
                    <v-icon start size="small">mdi-check</v-icon>Saved
                  </v-chip>
                </v-card-actions>
              </v-card>
            </v-col>

            <!-- Monitor Control Card -->
            <v-col cols="12" md="6">
              <v-card>
                <v-card-title>
                  <v-icon class="mr-2">mdi-monitor-eye</v-icon>Monitor Control
                </v-card-title>
                <v-card-text>
                  <div class="d-flex align-center mb-4">
                    <v-btn
                      v-if="!status.running"
                      color="success"
                      size="large"
                      variant="flat"
                      @click="startMonitor"
                      :loading="starting"
                    >
                      <v-icon start>mdi-play</v-icon>Start Monitoring
                    </v-btn>
                    <v-btn
                      v-else
                      color="error"
                      size="large"
                      variant="flat"
                      @click="stopMonitor"
                      :loading="stopping"
                    >
                      <v-icon start>mdi-stop</v-icon>Stop Monitoring
                    </v-btn>
                  </div>

                  <v-alert v-if="status.error" type="error" variant="tonal" density="compact" class="mb-3">
                    {{ status.error }}
                  </v-alert>

                  <v-table density="compact" v-if="status.running || status.samples > 0">
                    <tbody>
                      <tr>
                        <td class="text-medium-emphasis">Samples</td>
                        <td class="font-weight-bold">{{ status.samples }}</td>
                      </tr>
                      <tr v-if="status.start_time">
                        <td class="text-medium-emphasis">Started</td>
                        <td>{{ formatTime(status.start_time) }}</td>
                      </tr>
                      <tr v-if="status.current_log">
                        <td class="text-medium-emphasis">Log File</td>
                        <td class="text-caption">{{ status.current_log }}</td>
                      </tr>
                      <tr v-if="status.last_sample && status.last_sample.temp_c != null">
                        <td class="text-medium-emphasis">Temperature</td>
                        <td class="font-weight-bold">{{ status.last_sample.temp_c }} &deg;C</td>
                      </tr>
                      <tr v-if="status.last_sample && status.last_sample.cpu_percent != null">
                        <td class="text-medium-emphasis">CPU</td>
                        <td class="font-weight-bold">{{ status.last_sample.cpu_percent }}%</td>
                      </tr>
                      <tr v-if="status.last_sample && status.last_sample.mem_memfree_kb != null">
                        <td class="text-medium-emphasis">Memory Free</td>
                        <td class="font-weight-bold">{{ Math.round(status.last_sample.mem_memfree_kb / 1024) }} MB</td>
                      </tr>
                    </tbody>
                  </v-table>
                </v-card-text>
              </v-card>

              <div class="d-flex justify-center" style="margin: 0; padding: 0;">
                <img src="/static/radcam_spy.png" alt="RadCam Spy" style="max-width: 100%; max-height: 200px; width: auto; border-radius: 8px;" />
              </div>
            </v-col>
          </v-row>

          <!-- Live Chart -->
          <v-row v-if="status.running" class="mt-2">
            <v-col cols="12">
              <v-card>
                <v-card-title>
                  <v-icon class="mr-2">mdi-chart-timeline-variant</v-icon>Live Monitor
                </v-card-title>
                <v-card-text>
                  <div style="position: relative; height: 320px;">
                    <canvas ref="liveChart"></canvas>
                  </div>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>

          <!-- ISP Live Chart -->
          <v-row v-if="status.running" class="mt-2">
            <v-col cols="12">
              <v-card>
                <v-card-title>
                  <v-icon class="mr-2">mdi-camera-iris</v-icon>ISP Info
                </v-card-title>
                <v-card-text>
                  <div style="position: relative; height: 320px;">
                    <canvas ref="ispChart"></canvas>
                  </div>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>

          <!-- BlueOS File Browser -->
          <v-row class="mt-2">
            <v-col cols="12">
              <v-card>
                <v-card-title>
                  <v-icon class="mr-2">mdi-folder-open</v-icon>File Browser
                </v-card-title>
                <v-card-text class="pa-0">
                  <iframe
                    ref="fileBrowser"
                    style="width: 100%; height: 500px; border: none;"
                  ></iframe>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </v-container>
      </v-main>

      <!-- Snackbar -->
      <v-snackbar v-model="snackbar" :color="snackColor" timeout="3000" location="bottom right">
        {{ snackText }}
      </v-snackbar>
    </v-app>
  </div>

  <script>
    const { createApp, ref, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
    const { createVuetify } = Vuetify;

    const vuetify = createVuetify({
      theme: { defaultTheme: 'dark' },
    });

    Chart.defaults.color = '#8b8fa3';
    Chart.defaults.borderColor = '#2e3348';
    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.defaults.font.size = 11;
    Chart.defaults.animation.duration = 0;
    Chart.defaults.elements.point.radius = 0;
    Chart.defaults.elements.line.borderWidth = 1.5;

    const COLORS = {
      temp:     '#CC3311',
      cpu:      '#4477AA',
      mem:      '#228833',
      coreV:    '#AA3377',
      cpuV:     '#CCBB44',
      npuV:     '#66CCEE',
      iso:      '#EE6677',
      again:    '#4477AA',
      dgain:    '#228833',
      ispdgain: '#CCBB44',
      exptime:  '#AA3377',
      exposure: '#66CCEE',
    };

    function makeTimeLabels(records) {
      if (records.length === 0) return [];
      const t0 = records[0].ts || 0;
      return records.map(r => {
        const secs = (r.ts || 0) - t0;
        const m = Math.floor(secs / 60);
        const s = Math.round(secs % 60);
        return m + ':' + String(s).padStart(2, '0');
      });
    }

    function makeDataset(label, data, color, yAxisID, dashed) {
      return {
        label,
        data,
        borderColor: color,
        backgroundColor: color + '20',
        fill: !dashed,
        tension: 0.2,
        borderDash: dashed ? [6, 3] : [],
        yAxisID,
      };
    }

    function buildMultiAxisChart(canvas, records) {
      if (!canvas) return null;
      const labels = makeTimeLabels(records);
      const ctx = canvas.getContext('2d');
      return new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            makeDataset('Temp (°C)',  records.map(r => r.temp_c ?? null),        COLORS.temp,  'yLeft',  false),
            makeDataset('CPU (%)',    records.map(r => r.cpu_percent ?? null),    COLORS.cpu,   'yLeft',  false),
            makeDataset('Mem Used %', records.map(r => r.mem_used_percent ?? null), COLORS.mem, 'yLeft',  false),
            makeDataset('Core V',    records.map(r => r.core_volt ?? null),      COLORS.coreV, 'yRight', true),
            makeDataset('CPU V',     records.map(r => r.cpu_volt ?? null),       COLORS.cpuV,  'yRight', true),
            makeDataset('NPU V',     records.map(r => r.npu_volt ?? null),       COLORS.npuV,  'yRight', true),
          ],
        },
        options: {
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', axis: 'x', intersect: false },
          plugins: {
            legend: {
              position: 'top',
              labels: { boxWidth: 10, padding: 8, font: { size: 10 } },
            },
            tooltip: {
              mode: 'nearest',
              axis: 'x',
              intersect: false,
              callbacks: {
                label: function(ctx) {
                  const v = ctx.parsed.y;
                  if (v == null) return null;
                  const suffix = ctx.dataset.yAxisID === 'yRight' ? ' mV' : (ctx.dataset.label.includes('Temp') ? ' °C' : '%');
                  return ctx.dataset.label + ': ' + v + suffix;
                },
              },
            },
          },
          scales: {
            x: {
              ticks: { maxTicksLimit: 15 },
            },
            yLeft: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Temp (°C) / CPU (%) / Mem (%)' },
              beginAtZero: true,
            },
            yRight: {
              type: 'linear',
              position: 'right',
              title: { display: true, text: 'Voltage (mV)' },
              grid: { drawOnChartArea: false },
            },
          },
        },
      });
    }

    function buildISPChart(canvas, records) {
      if (!canvas) return null;
      const labels = makeTimeLabels(records);
      const ctx = canvas.getContext('2d');
      return new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            makeDataset('ISO',      records.map(r => r.isp_iso ?? null),      COLORS.iso,      'yLeft',  false),
            makeDataset('AGain',    records.map(r => r.isp_again ?? null),    COLORS.again,    'yLeft',  false),
            makeDataset('DGain',    records.map(r => r.isp_dgain ?? null),    COLORS.dgain,    'yLeft',  false),
            makeDataset('ISPDGain', records.map(r => r.isp_ispdgain ?? null), COLORS.ispdgain, 'yLeft',  false),
            makeDataset('ExpTime',  records.map(r => r.isp_exptime ?? null),  COLORS.exptime,  'yRight', true),
            makeDataset('Exposure', records.map(r => r.isp_exposure ?? null), COLORS.exposure,  'yRight', true),
          ],
        },
        options: {
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', axis: 'x', intersect: false },
          plugins: {
            legend: {
              position: 'top',
              labels: { boxWidth: 10, padding: 8, font: { size: 10 } },
            },
            tooltip: {
              mode: 'nearest',
              axis: 'x',
              intersect: false,
            },
          },
          scales: {
            x: {
              ticks: { maxTicksLimit: 15 },
            },
            yLeft: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'ISO / Gain' },
              beginAtZero: true,
            },
            yRight: {
              type: 'linear',
              position: 'right',
              title: { display: true, text: 'Exposure Time' },
              beginAtZero: true,
              grid: { drawOnChartArea: false },
            },
          },
        },
      });
    }

    const app = createApp({
      setup() {
        const settings = ref({ camera_ip: '192.168.2.10', telnet_user: 'root', telnet_password: '', interval: 2.0 });
        const showPassword = ref(false);
        const savingSettings = ref(false);
        const settingsSaved = ref(false);

        const status = ref({ running: false, error: null, samples: 0, start_time: null, last_sample: null, current_log: null });
        const starting = ref(false);
        const stopping = ref(false);

        const liveChart = ref(null);
        const ispChart = ref(null);
        const fileBrowser = ref(null);
        let liveChartInstance = null;
        let ispChartInstance = null;

        const snackbar = ref(false);
        const snackText = ref('');
        const snackColor = ref('success');

        let statusInterval = null;
        let liveInterval = null;

        function toast(msg, color = 'success') {
          snackText.value = msg;
          snackColor.value = color;
          snackbar.value = true;
        }

        async function apiFetch(url, opts = {}) {
          const res = await fetch(url, opts);
          return res.json();
        }

        const statusColor = computed(() => {
          if (status.value.error) return 'error';
          if (status.value.running) return 'success';
          return 'default';
        });

        const statusLabel = computed(() => {
          if (status.value.error) return 'Error';
          if (status.value.running) return 'Monitoring';
          return 'Idle';
        });

        async function fetchSettings() {
          try {
            const data = await apiFetch('/api/settings');
            settings.value = data;
          } catch (e) { console.error('Failed to load settings', e); }
        }

        async function saveSettings() {
          savingSettings.value = true;
          settingsSaved.value = false;
          try {
            await apiFetch('/api/settings', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(settings.value),
            });
            settingsSaved.value = true;
            toast('Settings saved');
            setTimeout(() => settingsSaved.value = false, 3000);
          } catch (e) {
            toast('Failed to save settings', 'error');
          } finally {
            savingSettings.value = false;
          }
        }

        async function fetchStatus() {
          try {
            const data = await apiFetch('/api/status');
            status.value = data;
          } catch (e) { console.error('Failed to fetch status', e); }
        }

        async function startMonitor() {
          starting.value = true;
          try {
            const data = await apiFetch('/api/start', { method: 'POST' });
            if (!data.success) {
              toast(data.message || 'Failed to start', 'error');
            } else {
              toast('Monitoring started');
              await fetchStatus();
              await nextTick();
              startLivePolling();
            }
          } catch (e) {
            toast('Failed to start monitoring', 'error');
          } finally {
            starting.value = false;
            await fetchStatus();
          }
        }

        async function stopMonitor() {
          stopping.value = true;
          stopLivePolling();
          try {
            await apiFetch('/api/stop', { method: 'POST' });
            toast('Monitoring stopped');
          } catch (e) {
            toast('Failed to stop monitoring', 'error');
          } finally {
            stopping.value = false;
            await fetchStatus();
          }
        }

        function startLivePolling() {
          stopLivePolling();
          fetchLive();
          liveInterval = setInterval(fetchLive, 2000);
        }

        function stopLivePolling() {
          if (liveInterval) { clearInterval(liveInterval); liveInterval = null; }
          if (liveChartInstance) { liveChartInstance.destroy(); liveChartInstance = null; }
          if (ispChartInstance) { ispChartInstance.destroy(); ispChartInstance = null; }
        }

        async function fetchLive() {
          if (!status.value.running) return;
          try {
            const data = await apiFetch('/api/live?limit=120');
            const records = data.records || [];
            if (records.length === 0) return;
            await nextTick();
            if (liveChartInstance) {
              updateChartData(liveChartInstance, records);
            } else if (liveChart.value) {
              liveChartInstance = buildMultiAxisChart(liveChart.value, records);
            }
            if (ispChartInstance) {
              updateISPChartData(ispChartInstance, records);
            } else if (ispChart.value) {
              ispChartInstance = buildISPChart(ispChart.value, records);
            }
          } catch (e) { console.error('Live fetch error', e); }
        }

        function updateChartData(chart, records) {
          const labels = makeTimeLabels(records);
          chart.data.labels = labels;
          chart.data.datasets[0].data = records.map(r => r.temp_c ?? null);
          chart.data.datasets[1].data = records.map(r => r.cpu_percent ?? null);
          chart.data.datasets[2].data = records.map(r => r.mem_used_percent ?? null);
          chart.data.datasets[3].data = records.map(r => r.core_volt ?? null);
          chart.data.datasets[4].data = records.map(r => r.cpu_volt ?? null);
          chart.data.datasets[5].data = records.map(r => r.npu_volt ?? null);
          chart.update('none');
        }

        function updateISPChartData(chart, records) {
          const labels = makeTimeLabels(records);
          chart.data.labels = labels;
          chart.data.datasets[0].data = records.map(r => r.isp_iso ?? null);
          chart.data.datasets[1].data = records.map(r => r.isp_again ?? null);
          chart.data.datasets[2].data = records.map(r => r.isp_dgain ?? null);
          chart.data.datasets[3].data = records.map(r => r.isp_ispdgain ?? null);
          chart.data.datasets[4].data = records.map(r => r.isp_exptime ?? null);
          chart.data.datasets[5].data = records.map(r => r.isp_exposure ?? null);
          chart.update('none');
        }

        watch(() => status.value.running, (running, wasRunning) => {
          if (running && !wasRunning) {
            nextTick(() => startLivePolling());
          } else if (!running && wasRunning) {
            stopLivePolling();
          }
        });

        function formatTime(iso) {
          if (!iso) return '—';
          try {
            const d = new Date(iso);
            return d.toLocaleString();
          } catch { return iso; }
        }

        onMounted(async () => {
          await Promise.all([fetchSettings(), fetchStatus()]);
          statusInterval = setInterval(fetchStatus, 2000);
          if (status.value.running) {
            await nextTick();
            startLivePolling();
          }
          if (fileBrowser.value) {
            fileBrowser.value.src = 'http://' + window.location.hostname + ':7777/files/extensions/radcam-spy';
          }
        });

        onUnmounted(() => {
          clearInterval(statusInterval);
          stopLivePolling();
        });

        return {
          settings, showPassword, savingSettings, settingsSaved, saveSettings,
          status, starting, stopping, startMonitor, stopMonitor,
          statusColor, statusLabel,
          liveChart, ispChart, fileBrowser,
          snackbar, snackText, snackColor,
          formatTime,
        };
      },
    });

    app.use(vuetify);
    app.mount('#app');
  </script>
</body>
</html>
